# Reactor反应器模式
反应器模式由Reactor反应器线程、Handlers处理器两大角色组成：
1. Reactor反应器线程的职责：负责响应IO事件，并且分发到Handlers处理
器。
2. Handlers处理器的职责：非阻塞的执行业务处理逻辑。

## 发展历程
* 最初和最原始的网络服务器程序，是用一个while循环，不断地监听端口是否有新的连接。前一个网络连接的handle（socket）没有处理完，
那么后面的连接请求没法被接收，于是后面的请求通通会被阻塞住，服务器的吞吐量就太低了。对于服务器来说，这是一个严重的问题。

* Connection Per  Thread（一个线程处理一个连接）模式。对于每一个新的网络连接都分配给一个线程。每个线程都独自处理自己负责的
输入和输出。当然，服务器的监听线程也是独立的，任何的socket连接的输入和输出处理，不会阻塞到后面新socket连接的监听和建立。早期版本的Tomcat服务器，
就是这样实现的。对应于大量的连接，需要耗费大量的线程资源，对线程资源要求太高。

* 单线程Reactor反应器模式

  有Reactor反应器和Handler处理器两个重要的组件

    1. Reactor反应器：负责查询IO事件，当检测到一个IO事件，将其发送给相
    应的Handler处理器去处理。这里的IO事件，就是NIO中选择器监控的通道IO事件。
    2. Handler处理器：与IO事件（或者选择键）绑定，负责IO事件的处理。完
    成真正的连接建立、通道的读取、处理业务逻辑、负责将结果写出到通道等。
    
   Reactor反应器和Handers处理器处于一个线程中执行。
   单线程Reactor反应器模式，是基于Java的NIO实现的。相对于传统的多线程
   OIO，反应器模式不再需要启动成千上万条线程，效率自然是大大提升了。
   在单线程反应器模式中，Reactor反应器和Handler处理器，都执行在同一条线程
   上。这样，带来了一个问题：当其中某个Handler阻塞时，会导致其他所有的Handler
   都得不到执行。在这种场景下，如果被阻塞的Handler不仅仅负责输入和输出处理的
   业务，还包括负责连接监听的AcceptorHandler处理器。这个是非常严重的问题。

* 多线程Reactor反应器模式

    多线程池Reactor反应器的演进，分为两个方面：
     1. 首先是升级Handler处理器。既要使用多线程，又要尽可能的高效率，则
    可以考虑使用线程池。
     1. 其次是升级Reactor反应器。可以考虑引入多个Selector选择器，提升选择
    大量通道的能力。
    
    总体来说，多线程池反应器的模式，大致如下：
    1. 将负责输入输出处理的IOHandler处理器的执行，放入独立的线程池中。
    这样，业务处理线程与负责服务监听和IO事件查询的反应器线程相隔离，避免服务
    器的连接监听受到阻塞。
    1. 如果服务器为多核的CPU，可以将反应器线程拆分为多个子反应器
    （SubReactor）线程；同时，引入多个选择器，每一个SubReactor子线程负责一个选
    择器。这样，充分释放了系统资源的能力；也提高了反应器管理大量连接，提升选
    择大量通道的能力

## 单线程Reactor反应器模式
  Reactor反应器和Handers处理器处于一个线程中执行